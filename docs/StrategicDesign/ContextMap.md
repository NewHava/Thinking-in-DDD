# 上下文映射图（Context Map）

## 1. 上下文映射图的概念

在 DDD 中，我们将业务领域划分为不同的限界上下文（Bound Context），每个上下文都代表着一组相关的业务概念和规则。这些上下文之间可能会存在各种关系，`Context Map`正是用于描述不同上下文之间的关系图，帮助我们更好地理解和管理这些关系，避免不同上下文之间的混乱和冲突，提高软件系统的可扩展性、可维护性和可理解性。同时，CONTEXT MAP 也是一种非常重要的沟通工具，可以帮助不同团队之间更好地协作和理解，共同构建出高质量的软件系统。

Context Map 通常包括以下几个部分：

- 限界上下文（Bounded Context）

即划分好的限界上下文（Bound Context）。

- 上下文映射（Context Mapping）

描述不同上下文之间的关系，可以帮助我们更好地理解和管理不同上下文之间的协作方式。

## 2. Bounded Context 之间的关系

限界上下文之间的关系，主要有：共享内核（Shared Kernel）、客户/供应商（Customer/Supplier）、跟随者（Conformist）、各行其道(SEPARATE WAY)、开放主机服务(Open Host Service)、防腐层(Anti-Corruption Layer)、发布语言（PUBLISHED LANGUAGE）。

限界上下文之间的映射，要考虑到《领域驱动设计》这本书的时代背景，当时业界大部分的应用都是单体应用，因此部分的映射关系放在单体应用上会更好理解。

## 3. 共享内核（Shared Kernel）

不同上下文之间存在共享的部分，包括共享的领域模型、代码库、基础设施等。共享内核一方面可以帮助我们避免重复开发和维护，提高系统的可扩展性和可维护性，另一方面共享内核也需要投入更多的精力才能确保两个上下文之间保持一致。

在共享内核中，各个上下文都可以对共用的部分进行开发和维护。

代码层面的共享内核，实际上是两个限定上下文同时引用了某个类，这个类由两个限界上下文共同维护，当某个限界上下文对该类进行改动时，必须及时将调整同步到其他使用该类的团队，其他团队更新代码并进行回归测试，确保该类的改动不会引起问题。

基础设施层面的共享内核，举个例子，网关和认证服务共用了一个缓存，当用户认证通过时，认证服务将凭据写入到缓存中，网关通过读取缓存获取用户的授权凭据。

共享内核表达的是两个限界上下文共同维护共享的内容，两个限界上下文彼此的开发团队都可以根据需要往公共的模型中增加能力。

举个例子，有 A 和 B 两个限界上下文，分别对应 A 代码库和 B 代码库，其中 B 引用了 A 中的某个 SharedClass 类，当 B 需要扩展这个 SharedClass 类时，直接到 A 代码库中对 SharedClass 类进行扩展。

通俗来说，就是下游把上游的上下文引入到自己的上下文中，并且下游有上游的代码库权限，下游想要什么能力就去上游的代码里写。

## 4. 客户/供应商（Customer/Supplier）

下游系统依赖上游系统，下游需要的能力只能由上游提供，我们将下游系统称之为“客户”，上游系统称之为“供应商”，这就是“客户/供应商”（Customer/Supplier）模式。

客户/供应商双方进行沟通，确定供应商需要给客户提供的能力，之后由供应商在自己的限界上下文内完成完成领域模型开发，并将形成的产物交付给下游系统使用。

客户/供应商之间可能通过接口、消息等方式进行交互，并不会共享领域模型的代码。

在开发中客户/供应商模式很常见，以下场景其实都是客户/供应商。

- 下游系统要求上游系统提供一个新的接口（或者消息）。

- 下游系统要求上游系统在已有的接口（或者消息）中增加新的字段。

通俗来讲，就是下游给上游提需求，上下游沟通之后，由上游在自己的上下文中进行开发，并将开发的能力提供给下游。

## 5. 跟随者（Conformist）

当下游需要上游提供的能力，上游不能积极响应时，下游可能会将上游的领域模型引入到自己的上下文中，并在自己的上下文中对上游的领域模型进行扩展，这就是跟随者（Conformist）。

跟随者与共享内核的相同点：

- 两个限界上下文都会有共用的部分。

跟随者与共享内核的不相同点：

- 共享内核由两个限界上下文的团队共同维护，彼此沟通协调一起维护模型；跟随者则是上游系统不响应下游系统的需求，下游系统自己将上游系统的模型整合到上下文中并进行扩展。

通俗来讲，就是下游向上游提需求，上游不接需求并且告诉下游，我把代码打个 jar 包给你，你自己把 jar 包引入到自己上下文里进行扩展。

## 6. 各行其道(SEPARATE WAY)

两个上下文之间联系不紧密，因此各自独立实现自己需要的领域逻辑。

通俗来讲，就是各干各的，自己需要啥就在自己的上下文中开发。

## 7. 开放主机服务(Open Host Service)

开放主机服务（Open Host Service）是指将领域模型的能力通过协议开放为服务供其他系统访问。

开放主机服务的核心思想是将领域模型封装为一个服务，该服务提供了一系列通用的接口，用于与外部系统进行交互。这些接口可以是基于 SOAP、REST、RPC 或其他协议实现的，具体实现方式取决于具体的业务需求和技术选型。

## 8. 防腐层(Anti-Corruption Layer)

将在[防腐层(Anti-Corruption Layer)](./ACL.md)中进行讲解。

## 9. 发布语言(Published Language)

发布语言(Published Language)是用于两个限界上下文之间的进行模型转换的公共语言。

在开放主机服务(Open Host Service)中，服务的调用方团队则必须学习 HOST 团队所使用的专用术语，例如 HOST 团队专门自定义了一套通信协议。发布语言(Published Language)则强调上下游交互时，选择一种双方都容易处理的语言进行数据交换。

在当前业界一般采用 JSON 进行数据交换，例如接口返回 JSON 数据，消息队列的消息体采用 JSON 字符串，因此，我们可以选择 JSON 作为两个上下文之间数据交换的语言。

<!--@include: ../footer.md-->

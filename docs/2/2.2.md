# 2.2 贫血模型和充血模型

在学习贫血模型和充血模型之前，首先要理解对象的属性和对象的行为这两个概念。

对象的属性：指的是对象的内部状态，通常表现为类的property。

对象的行为：指的是对象具备的能力，也就是我们所预期的业务逻辑，通常表现为类的method。

## 2.2.1 贫血模型

贫血模型指的是只有属性没有行为的模型。我们目前开发中经常用的Java Bean，实际上就是贫血模型，例如：

```java
/**
 * Computer类中只有属性，没有行为，所以是贫血模型
 */
@Data
public class Computer {

    /**
     * 操作系统
     */
    private String os;

    /**
     * 键盘
     */
    private String keyboard;
    //……其他属性
}
```

## 2.2.2 充血模型

充血模型是指既有属性也有行为的模型。

如果我们采用面向对象的思想去建模，则产出的模型应该既有属性，也有行为，那么这种模型就是充血模型。例如下面的VideoPlayer类，既有属性（playlist），也有行为（play方法），则VideoPlayer是充血模型：

```java
/**
 * 视频播放器
 */
@Data
public class VideoPlayer {
    /**
     * 播放列表
     */
    public List<String> playlist;

    /**
     * 播放节目
     */
    public void play() {
        for (String v : playlist) {
            System.out.printf("正在播放：" + v);
        }
    }
}
```

### 2.2.3 DDD对模型的要求

大部分Java程序员习惯了使用贫血模型：先通过ORM框架从数据库查询数据，然后在Service层的方法中操作这些数据对象完成业务逻辑，然后Service层中调用ORM框架对数据库做更新。Service承担了实现所有业务逻辑的责任，稍微遗漏了业务逻辑的约束，就会造成问题。

DDD要求充血模型的原因在于模型的行为也是模型的一部分。贫血模型只是提供了属性数据的容器，然后向Service公开了这些属性，操作这些属性完成业务逻辑的职责转嫁给了Service，这会导致Service所有的方法都必须充分了解模型的领域知识，面向对象三大特征之一的封装性荡然无存。

我们经常看到某个业务校验的逻辑在每个Service方法里面都出现一次，就是贫血模型泄漏了领域知识造成的。

充血模型拥有完整的属性，同时具备业务行为（即业务方法），因此Service只要调用充血模型的行为，充血模型内部即自行修改对应的状态以完成业务操作，Service再也不需要理解领域的业务规则了，因为都是充血模型自己在维护。

以上面的VideoPlayer为例：

```java
public class VideoService {

    public void play() {
        //TODO 1.获得领域对象

        //2. 执行业务操作，Service只需要调用充血模型的行为就能完成业务操作，
        //   不再需要了解播放的逻辑    
        videoPlayer.play();
    }
}

```
可以看到，当采用充血模型的建模方式后，业务逻辑由对应的充血模型进行维护，很好地被封装在充血模型中，Service方法会变得清晰明了。
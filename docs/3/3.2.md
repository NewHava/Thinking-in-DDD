# 3.2 聚合与聚合根

## 3.2.1 聚合与聚合根的定义

实体和值对象是对领域知识的建模，而聚合与聚合根则是对领域模型一致性的建模。

采用面向对象的方式对领域知识进行建模之后，得到了实体和值对象两类领域模型。这些模型不会孤立地存在，往往存在引用关系，形成一棵对象树。

这颗对象树，就是一个聚合(Aggregate)。

聚合根则是指这棵对象树的根（Root），聚合根必须是一个实体（Entity）。

举个例子，下面Role类就是一个聚合，并且聚合根就是Role这个类，可以它遍历访问到聚合内所有的状态。

```java

public class Role {
    private Long roleId;
    private String roleName;
    private Set<ResourceId> resourceIds;

    public void modifyRoleName(String roleName) {
        this.roleName = roleName;
    }

    public void addResource(ResourceId resourceId) {
        this.resourceIds.add(resourceId);
    }
}
```

## 3.2.2 聚合与聚合根的作用

聚合用来表示一致性的范围，聚合内的领域对象都必需接受一致性约束，聚合内的对象状态强一致，聚合之间最终一致。

以Role为例，修改角色名称时，只是修改了roleName的值，并没有修改角色对应的资源，所以保存Role时，不能造成resourceIdList值的变化。

```java
public class RoleApplicationService {
    private RoleRepository roleRepository;

    public void modifyRoleName(Long roleId, String roleName) {
        Role role = roleRepository.load(roleId);
        role.modifyRoleName(roleName);
        roleRepository.save(role);
    }
}
```

同时，聚合内的对象都必需满足固定的业务规则，可以起到维护业务规则的作用。

聚合根可以控制外部对聚合内对象的访问，外部对象只能引用聚合根，不能直接引用聚合内的对象，避免了外部对象绕开聚合根来修改内部对象的状态，确保任何状态变化都满足聚合的固定规则。

以Role这个聚合为例，当需要给角色添加资源时，我们时直接通过聚合根Role提供的addResource方法进行操作，并不是返回了resourceIds，通过resourceIds进行添加。

```java
/**
 * 以下是正例，通过聚合根操作内部状态
 */
public class RoleApplicationService {
    private RoleRepository roleRepository;

    public void addResource(Long roleId, Long resourceId) {
        Role role = roleRepository.load(roleId);
        role.addResource(new ResourceId(resourceId));
        roleRepository.save(role);
    }
}
```

```java
/**
 * 以下是反例，暴露聚合内的状态，直接绕开聚合根进行操作
 */
public class RoleApplicationService {
    private RoleRepository roleRepository;

    public void addResource(Long roleId, Long resourceId) {
        Role role = roleRepository.load(roleId);
        //错误！对外暴露了聚合内部的状态
        Set<ResourceId> resourceIds = role.getResourceIds();
        //错误！绕开聚合根操作聚合内部状态
        resourceIds.add(new ResourceId(resourceId));
        roleRepository.save(role);
    }
}
```

相应的，聚合根内部的对象也只能持有其他对象聚合根的引用，而且往往只会持有聚合根实体的ID。

外部对象如果需要获取聚合的内部状态，可以通过返回一个副本，避免了外部私自修改的风险。

示例如下，**getResourceIds**方法返回了一个新的Set，调用方修改这个Set，不会影响到聚合内部状态

```java
public class Role {
    private Long roleId;
    private String roleName;
    private Set<ResourceId> resourceIds;

    //省略其他方法

    /**
     * 当需要暴露聚合内部状态时，不能直接返回内部状态的引用，而是应当返回一个副本
     * @return resourceIds副本
     */
    public Set<ResourceId> getResourceIds() {
        return new HashSet<>(resourceIds);
    }
}
```

只有聚合根才能直接通过数据库查询获取，因此只有聚合根拥有Repository。

聚合根的Repository只有两个方法：load和save。

load：通过聚合根实体ID加载聚合根。

save：保存聚合根，注意要加事务。

示例：

```java
public class RoleRepository {
    public Role load(RoleId roleId) {
        //TODO 从数据库查询Role相关的数据对象

        //TODO 将数据对象转成领域对象，返回
    }

    /**
     * 保存领域对象，事务操作
     * @param role 领域对象
     */
    @Transationnal
    public void save(Role role) {
        //TODO 将领域模型转成数据模型

        //TODO 将数据模型保存到数据库中
    }
}

```
